import type {
  EndpointData,
  EntityMappingConfig,
} from "@home-assistant-matter-hub/common";
import ArrowDownwardIcon from "@mui/icons-material/ArrowDownward";
import ArrowUpwardIcon from "@mui/icons-material/ArrowUpward";
import DevicesIcon from "@mui/icons-material/Devices";
import RefreshIcon from "@mui/icons-material/Refresh";
import Alert from "@mui/material/Alert";
import Box from "@mui/material/Box";
import Button from "@mui/material/Button";
import Card from "@mui/material/Card";
import CardContent from "@mui/material/CardContent";
import CircularProgress from "@mui/material/CircularProgress";
import FormControl from "@mui/material/FormControl";
import Grid from "@mui/material/Grid";
import IconButton from "@mui/material/IconButton";
import InputLabel from "@mui/material/InputLabel";
import MenuItem from "@mui/material/MenuItem";
import Pagination from "@mui/material/Pagination";
import Select from "@mui/material/Select";
import Snackbar from "@mui/material/Snackbar";
import Stack from "@mui/material/Stack";
import TextField from "@mui/material/TextField";
import Tooltip from "@mui/material/Tooltip";
import Typography from "@mui/material/Typography";
import { useCallback, useEffect, useMemo, useState } from "react";
import {
  fetchEntityMappings,
  updateEntityMapping,
} from "../../api/entity-mappings";
import { EndpointCard } from "../../components/endpoints/EndpointCard";
import { getEndpointName } from "../../components/endpoints/EndpointName";
import { EntityMappingDialog } from "../../components/entity-mapping/EntityMappingDialog";
import { useBridges } from "../../hooks/data/bridges";
import { loadBridges } from "../../state/bridges/bridge-actions";
import { loadDevices } from "../../state/devices/device-actions";
import { useAppDispatch, useAppSelector } from "../../state/hooks";

interface DeviceInfo {
  bridgeId: string;
  bridgeName: string;
  endpoint: EndpointData;
}

export const DevicesPage = () => {
  const dispatch = useAppDispatch();
  const { content: bridges, isLoading: bridgesLoading } = useBridges();
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedBridge, setSelectedBridge] = useState<string>("");
  const [selectedType, setSelectedType] = useState<string>("");
  const [sortBy, setSortBy] = useState<"name" | "type" | "bridge">("name");
  const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc");
  const [page, setPage] = useState(1);
  const itemsPerPage = 12;

  // Entity Mapping Dialog state
  const [mappingDialogOpen, setMappingDialogOpen] = useState(false);
  const [selectedEntityId, setSelectedEntityId] = useState<string>("");
  const [selectedMappingBridgeId, setSelectedMappingBridgeId] =
    useState<string>("");
  const [currentMapping, setCurrentMapping] = useState<
    EntityMappingConfig | undefined
  >();
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: "success" | "error";
  }>({ open: false, message: "", severity: "success" });

  // Load bridges on mount
  useEffect(() => {
    dispatch(loadBridges());
  }, [dispatch]);

  // Load devices for each bridge
  useEffect(() => {
    if (bridges) {
      bridges.forEach((bridge) => {
        dispatch(loadDevices(bridge.id));
      });
    }
  }, [dispatch, bridges]);

  // Get all device states from Redux
  const allDeviceStates = useAppSelector((state) => state.devices.byBridge);

  // Recursively collect all leaf endpoints (actual devices, not aggregators)
  const collectDeviceEndpoints = useCallback(
    (
      endpoint: EndpointData,
      bridgeId: string,
      bridgeName: string,
    ): DeviceInfo[] => {
      const results: DeviceInfo[] = [];

      // If this endpoint has no children, it's a leaf device
      if (!endpoint.parts || endpoint.parts.length === 0) {
        // Skip the root node itself (usually has endpoint number 0)
        if (endpoint.endpoint !== 0) {
          results.push({ bridgeId, bridgeName, endpoint });
        }
      } else {
        // Recursively collect from children
        for (const child of endpoint.parts) {
          results.push(...collectDeviceEndpoints(child, bridgeId, bridgeName));
        }
      }

      return results;
    },
    [],
  );

  // Extract all endpoints from all bridges
  const devices = useMemo(() => {
    const allDevices: DeviceInfo[] = [];

    (bridges || []).forEach((bridge) => {
      const deviceState = allDeviceStates[bridge.id];
      const rootEndpoint = deviceState?.content;

      if (rootEndpoint) {
        allDevices.push(
          ...collectDeviceEndpoints(rootEndpoint, bridge.id, bridge.name),
        );
      }
    });

    return allDevices;
  }, [bridges, allDeviceStates, collectDeviceEndpoints]);

  const isLoading =
    bridgesLoading || (bridges && bridges.length > 0 && devices.length === 0);

  // Filter devices
  const filteredDevices = useMemo(() => {
    return devices.filter((device) => {
      const deviceName =
        getEndpointName(device.endpoint.state) ?? device.endpoint.id.local;
      const deviceType = device.endpoint.type.name;

      const matchesSearch =
        deviceName.toLowerCase().includes(searchTerm.toLowerCase()) ||
        device.bridgeName.toLowerCase().includes(searchTerm.toLowerCase()) ||
        deviceType.toLowerCase().includes(searchTerm.toLowerCase());

      const matchesBridge =
        !selectedBridge || device.bridgeId === selectedBridge;
      const matchesType = !selectedType || deviceType === selectedType;

      return matchesSearch && matchesBridge && matchesType;
    });
  }, [devices, searchTerm, selectedBridge, selectedType]);

  // Sort devices
  const sortedDevices = useMemo(() => {
    const sorted = [...filteredDevices].sort((a, b) => {
      const nameA = getEndpointName(a.endpoint.state) ?? a.endpoint.id.local;
      const nameB = getEndpointName(b.endpoint.state) ?? b.endpoint.id.local;

      let comparison = 0;
      switch (sortBy) {
        case "name":
          comparison = nameA.localeCompare(nameB);
          break;
        case "type":
          comparison = a.endpoint.type.name.localeCompare(b.endpoint.type.name);
          // Secondary sort by name within same type
          if (comparison === 0) {
            comparison = nameA.localeCompare(nameB);
          }
          break;
        case "bridge":
          comparison = a.bridgeName.localeCompare(b.bridgeName);
          // Secondary sort by name within same bridge
          if (comparison === 0) {
            comparison = nameA.localeCompare(nameB);
          }
          break;
      }
      return sortDirection === "asc" ? comparison : -comparison;
    });
    return sorted;
  }, [filteredDevices, sortBy, sortDirection]);

  // Pagination
  const totalPages = Math.ceil(sortedDevices.length / itemsPerPage);
  const paginatedDevices = sortedDevices.slice(
    (page - 1) * itemsPerPage,
    page * itemsPerPage,
  );

  // Get unique device types
  const deviceTypes = useMemo(() => {
    const types = new Set(devices.map((d) => d.endpoint.type.name));
    return Array.from(types).sort();
  }, [devices]);

  const handleRefresh = useCallback(() => {
    dispatch(loadBridges());
  }, [dispatch]);

  const handleEditMapping = useCallback(
    async (entityId: string, bridgeId: string) => {
      setSelectedEntityId(entityId);
      setSelectedMappingBridgeId(bridgeId);
      try {
        const mappings = await fetchEntityMappings(bridgeId);
        const existingMapping = mappings.mappings.find(
          (m) => m.entityId === entityId,
        );
        setCurrentMapping(existingMapping);
      } catch {
        setCurrentMapping(undefined);
      }
      setMappingDialogOpen(true);
    },
    [],
  );

  const handleSaveMapping = useCallback(
    async (config: Partial<EntityMappingConfig>) => {
      if (!selectedMappingBridgeId || !selectedEntityId) return;
      try {
        await updateEntityMapping(
          selectedMappingBridgeId,
          selectedEntityId,
          config,
        );
        setSnackbar({
          open: true,
          message: `Mapping saved for ${selectedEntityId}. Restart the bridge to apply changes.`,
          severity: "success",
        });
        setMappingDialogOpen(false);
      } catch (error) {
        setSnackbar({
          open: true,
          message: `Failed to save mapping: ${error}`,
          severity: "error",
        });
      }
    },
    [selectedMappingBridgeId, selectedEntityId],
  );

  if (isLoading) {
    return (
      <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ p: 2 }}>
      <Typography
        variant="h4"
        gutterBottom
        sx={{ display: "flex", alignItems: "center", gap: 2 }}
      >
        <DevicesIcon />
        All Devices
        <Button
          variant="outlined"
          startIcon={<RefreshIcon />}
          onClick={handleRefresh}
          sx={{ ml: "auto" }}
        >
          Refresh
        </Button>
      </Typography>

      {/* Filters */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Stack
            spacing={2}
            direction={{ xs: "column", md: "row" }}
            alignItems={{ md: "center" }}
          >
            <TextField
              label="Search devices..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              sx={{ flexGrow: 1 }}
            />

            <FormControl sx={{ minWidth: 200 }}>
              <InputLabel>Bridge</InputLabel>
              <Select
                value={selectedBridge}
                label="Bridge"
                onChange={(e) => setSelectedBridge(e.target.value)}
              >
                <MenuItem value="">All Bridges</MenuItem>
                {(bridges || []).map((bridge) => (
                  <MenuItem key={bridge.id} value={bridge.id}>
                    {bridge.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <FormControl sx={{ minWidth: 200 }}>
              <InputLabel>Device Type</InputLabel>
              <Select
                value={selectedType}
                label="Device Type"
                onChange={(e) => setSelectedType(e.target.value)}
              >
                <MenuItem value="">All Types</MenuItem>
                {deviceTypes.map((type) => (
                  <MenuItem key={type} value={type}>
                    {type}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <FormControl sx={{ minWidth: 150 }}>
              <InputLabel>Sort By</InputLabel>
              <Select
                value={sortBy}
                label="Sort By"
                onChange={(e) =>
                  setSortBy(e.target.value as "name" | "type" | "bridge")
                }
              >
                <MenuItem value="name">Name</MenuItem>
                <MenuItem value="type">Device Type</MenuItem>
                <MenuItem value="bridge">Bridge</MenuItem>
              </Select>
            </FormControl>

            <Tooltip
              title={sortDirection === "asc" ? "Ascending" : "Descending"}
            >
              <IconButton
                onClick={() =>
                  setSortDirection((prev) => (prev === "asc" ? "desc" : "asc"))
                }
                color="primary"
              >
                {sortDirection === "asc" ? (
                  <ArrowUpwardIcon />
                ) : (
                  <ArrowDownwardIcon />
                )}
              </IconButton>
            </Tooltip>
          </Stack>
        </CardContent>
      </Card>

      {/* Device Grid */}
      <Grid container spacing={2}>
        {paginatedDevices.map((device) => (
          <Grid
            key={`${device.bridgeId}-${device.endpoint.id.global}`}
            size={{ xs: 12, sm: 6, lg: 4 }}
          >
            <EndpointCard
              endpoint={device.endpoint}
              bridgeName={device.bridgeName}
              bridgeId={device.bridgeId}
              onEditMapping={handleEditMapping}
            />
          </Grid>
        ))}
      </Grid>

      {/* Pagination */}
      {totalPages > 1 && (
        <Box sx={{ display: "flex", justifyContent: "center", mt: 3 }}>
          <Pagination
            count={totalPages}
            page={page}
            onChange={(_, newPage) => setPage(newPage)}
            color="primary"
          />
        </Box>
      )}

      {filteredDevices.length === 0 && (
        <Box sx={{ textAlign: "center", py: 8 }}>
          <Typography variant="h6" color="text.secondary">
            No devices found
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Try adjusting your filters or check if any bridges are running
          </Typography>
        </Box>
      )}

      {/* Entity Mapping Dialog */}
      <EntityMappingDialog
        open={mappingDialogOpen}
        entityId={selectedEntityId}
        domain={selectedEntityId.split(".")[0] || ""}
        currentMapping={currentMapping}
        onSave={handleSaveMapping}
        onClose={() => setMappingDialogOpen(false)}
      />

      {/* Snackbar for feedback */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar((prev) => ({ ...prev, open: false }))}
      >
        <Alert
          onClose={() => setSnackbar((prev) => ({ ...prev, open: false }))}
          severity={snackbar.severity}
          sx={{ width: "100%" }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};
